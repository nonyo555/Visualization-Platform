
        <head>
        <script src="https://d3js.org/d3.v5.js"></script>
        <script src="https://d3js.org/d3-color.v2.min.js"></script>
        <script src="https://d3js.org/d3-path.v2.min.js"></script>
        <script src="https://d3js.org/d3-chord.v2.min.js"></script>
    </head>

    <body>
      <div style="position: relative;">
      <svg id ='graph'>
      </svg>
      </div>
      </div>
      
    <script>
        var dataset = [{"source":"France","target":"Britain","value":"22.4"},{"source":"Greece","target":"Britain","value":"0.55"},{"source":"Italy","target":"Britain","value":"26"},{"source":"Portugal","target":"Britain","value":"19.4"},{"source":"United States","target":"Britain","value":"345"},{"source":"Germany","target":"France","value":"53.8"},{"source":"Greece","target":"France","value":"53.9"},{"source":"Ireland","target":"France","value":"17.3"},{"source":"Italy","target":"France","value":"366"},{"source":"Japan","target":"France","value":"7.73"},{"source":"Portugal","target":"France","value":"18.3"},{"source":"Spain","target":"France","value":"118"},{"source":"United States","target":"France","value":"322"},{"source":"Britain","target":"Germany","value":"321"},{"source":"Greece","target":"Germany","value":"19.3"},{"source":"Ireland","target":"Germany","value":"48.9"},{"source":"Portugal","target":"Germany","value":"32.5"},{"source":"Spain","target":"Germany","value":"57.6"},{"source":"United States","target":"Germany","value":"324"},{"source":"Britain","target":"Ireland","value":"12"},{"source":"Greece","target":"Ireland","value":"0.34"},{"source":"Spain","target":"Ireland","value":"6.38"},{"source":"Germany","target":"Italy","value":"111"},{"source":"Greece","target":"Italy","value":"3.22"},{"source":"Ireland","target":"Italy","value":"2.83"},{"source":"Portugal","target":"Italy","value":"0.87"},{"source":"Britain","target":"Japan","value":"28.2"},{"source":"Germany","target":"Japan","value":"88.5"},{"source":"Greece","target":"Japan","value":"1.37"},{"source":"Ireland","target":"Japan","value":"18.9"},{"source":"Italy","target":"Japan","value":"38.8"},{"source":"Portugal","target":"Japan","value":"2.18"},{"source":"Spain","target":"Japan","value":"25.9"},{"source":"United States","target":"Japan","value":"796"},{"source":"Greece","target":"Portugal","value":"10.1"},{"source":"Ireland","target":"Portugal","value":"3.77"},{"source":"United States","target":"Portugal","value":"0.52"},{"source":"Britain","target":"Spain","value":"326"},{"source":"Greece","target":"Spain","value":"0.78"},{"source":"Italy","target":"Spain","value":"9.79"},{"source":"Portugal","target":"Spain","value":"62"},{"source":"United States","target":"Spain","value":"163"},{"source":"Greece","target":"United States","value":"3.1"},{"source":"Ireland","target":"United States","value":"11.1"},{"source":"Italy","target":"United States","value":"3.16"}]
        function chords(data,width,height,ribbons,paths,jsonColor){
    var innerRadius = Math.min(width, height) * 0.5 - 20
    var outerRadius = innerRadius + 6
    var names = Array.from(new Set(data.flatMap(d => [d.source, d.target])))
    const index = new Map(names.map((name, i) => [name, i]));
    var matrix = Array.from(index, () => new Array(names.length).fill(0));
    for (const {source, target, value} of data) matrix[index.get(source)][index.get(target)] += value;
    //console.log(matrix)
    var chord = d3.chordDirected()
        .padAngle(12 / innerRadius)
        .sortSubgroups(d3.descending)
        .sortChords(d3.descending)
    var arc = d3.arc()
        .innerRadius(innerRadius)
        .outerRadius(outerRadius)
    
    var ribbon = d3.ribbonArrow()
        .radius(innerRadius - 0.5)
        .padAngle(1 / innerRadius)

    console.log(names)
    var color = d3.scaleOrdinal(names, d3.schemeCategory10)
    // Object.keys(jsonColor).forEach(key => {
    //     color[names.indexOf(keu)] = jsonColor[key]
    // });
    // console.log(color)

    //div
    const div =d3.select('div')
        .style('width',width*1.1)
        .style('height',height*1.1)

function dragstarted(event) {
  d3.select(this).raise()
  .attr("stroke", "red")
  .attr("stroke-opacity",0.5)
  .style("stroke-width", "8px")
}
var maxRow = matrix.map(function(row){ return Math.max.apply(Math, row); });
var minRow = matrix.map(function(row){ return Math.min.apply(Math, row); });
var max = Math.max.apply(null, maxRow);
var min = Math.min.apply(null, minRow);
const lineW= 12
const radius = 20
const firHy = ((height*-0.476)+(radius/2))
const secHy = ((height*-0.476)+(height*0.95)-(radius/2))



divided= (max-min)/(((height*-0.476)+(height*0.95)-(radius/2))-((height*-0.476)+(radius/2)))
function dragged(event, d) {
  if (this.id == "firstHandle" ){
    if (d3.event.y < parseFloat(secH.attr('cy'))){
       firH.attr("cy",  d3.event.y);
    }
  else{
       firH.attr("cy",  secH.attr("cy"));
  }
  }
  else if (this.id == "secondHandle" ) {
    if (d3.event.y > parseFloat(firH.attr('cy'))){
      secH.attr("cy",  d3.event.y);
    }
    else{
      secH.attr("cy",   firH.attr("cy"));
 }
  }
  if (firH.attr('cy')<firHy){
    firH.attr("cy",   firHy);
  }
  else if (secH.attr('cy')>secHy){
    secH.attr("cy",   secHy);
  }

let maxV = parseInt(max- ((firH.attr('cy')-firHy)*divided)).toString()
let minV =  parseInt(((secHy-secH.attr('cy'))*divided)+min).toString()
labelTop.text(maxV)
labelDown.text(minV)
}

function arcTween(d) {
  let interpolateStart = d3.interpolate(oldPathValue[d.index].startAngle, d.startAngle);
  let interpolateEnd = d3.interpolate(oldPathValue[d.index].endAngle, d.endAngle);
  return function(t) {
    return arc({
      startAngle: interpolateStart(t),
      endAngle: interpolateEnd(t),
    });
}
}


function dragended(event, d) {
  d3.select(this).attr("stroke", null);
  render()
}
drag = d3.drag()
    .on("start", dragstarted)
    .on("drag", dragged)
    .on("end", dragended);
    // input range
    d3.select('input')
        .style('position','absolute')
        .style('right','0px')

    const svg = d3.select("#graph")
        .style('width',width)
        .style('height',height)
        .style('position','fixed')

  
        .attr("viewBox", [-width / 1.8, -height / 1.8, width*1.2, height*1.2]);
    const chords = chord(matrix);
    
    const line = svg.append('rect')
            .style('width',lineW)
            .style('height',height*0.95)
            .attr('x',width *0.595)
            .attr('y',height*-0.476)
            .attr("rx", 6)
            .attr("ry", 6)
            .attr('fill','red')
            .attr('fill-opacity',0.5)
    const firH =  svg.append('circle')
        .attr('cx',(width *0.595)+(lineW/2))
        .attr('cursor','pointer')
        .attr('cy',firHy)
        .attr('r',radius)
        .attr('id','firstHandle')
        .attr('fill','red')
        .call(drag)
    const secH =  svg.append('circle')
        .attr('cx',(width *0.595)+(lineW/2))
        .attr('cursor','pointer')
        .attr('cy',secHy)
        .attr('r',radius)
        .attr('id','secondHandle')
        .attr('fill','red')
        .call(drag)
    const labelTop = svg
          .append('text')
          .attr('id','range')
          .attr('type','number')
          .attr('x',width *0.595+(lineW/2))
          .attr('y',firHy-30)
          .style("text-anchor", "middle")
          .style("font-style","Serif")
          .style('font-size',20)
          .text (max.toString())
    const labelDown = svg
          .append('text')
          .attr('id','range')
          .attr('type','number')
          .attr('x',width *0.595+(lineW/2))
          .attr('y',secHy +40)
          .style('font-size',20)
          .style("text-anchor", "middle")
          .text (min.toString())


    svg.append("path")
        .attr("fill", "none")
        .attr("d", d3.arc()({outerRadius, startAngle: 0, endAngle: 2 * Math.PI}))

    svg.append("g")
    .attr("fill-opacity", 0.75)
    .selectAll("g")
    .data(chords)
    .join("path")
    .attr('id','ribbon')
    .attr("d", ribbon)
    .attr("fill", d => color(names[d.target.index]))
    .style("mix-blend-mode", "multiply")
    .append("title")
    .text(d => `${ribbons[0]} ${names[d.source.index]} ${ribbons[1]}${names[d.target.index]} ${ribbons[2]} ${d.source.value} ${ribbons[3]}`);
    
    svg.append("g")
    .attr('id','colorline')
    .attr("font-family", "bold serif")
    .attr("font-weight",900)
    .attr("font-size", () =>{
      if(parseInt(width/56<12)){
        return 12
      }
      else if(parseInt(width/56>25)){
        return 25
      }
      return parseInt(width/56>25 )

     }) //15
    .selectAll("g")
    .data(chords.groups)
    .join("g")
    .call(g => g.append("path")
      .attr("d", arc)
      .attr('id','colorline')
      .attr('cursor','pointer')
      .each(d=> {d.clicked = false})
      .on('click',pathMouseClicked)
      .on('mouseover',pathMouseOver)
      .on('mouseout',pathMouseOut)
      .attr("fill", d =>  color(names[d.index]))
      .attr("stroke", d => color(names[d.index]))
      .attr('stroke-width', 3))
      .call(g => g.append("text")
                .each(d => (d.angle = (d.startAngle + d.endAngle) / 2))
                .attr("dy", '0.35em')
                .attr('id',d=>names[d.index])
                .attr("transform", d => `
                    rotate(${(d.angle * 180 / Math.PI - 90)})
                    translate(${outerRadius + 5})
                    ${d.angle > Math.PI ? "rotate(180)" : ""}
                    `)
                .attr("text-anchor", d => d.angle > Math.PI ? "end" : null)
                .text(d => names[d.index]))
        .call(g => g.append("title")
       // .attr('id','colorline')
    .text(d => ` ${paths[0]}${names[d.index]} ${paths[1]} ${d3.sum(matrix[d.index])} ${paths[2]} ${d3.sum(matrix, row => row[d.index])}  ${paths[3]}`));

  var oldPathValue =  d3.selectAll('#colorline').selectAll('path').data()

  function pathMouseOver (event,d){
    d3.select(this)
    .attr('stroke-width', 7)

  }
  function pathMouseClicked (event,index){
      //let sel =
      svg.selectAll('path')
        .attr("fill-opacity", 0.3)
      d3.select(this)
        .attr("fill-opacity", 1)
      allRib = d3.selectAll('#ribbon')
      let chCliked = d3.select(this).data()[0].clicked
      if(chCliked == false){
        allRib.each((d,i)=>{
              if (d.source.index == index ||d.target.index == index ){ 
                d3.select(allRib._groups[0][i])
                    .attr("fill-opacity", 0.75)
              }
        })
        d3.select(this).data()[0].clicked = true
      }
      else{
        d3.selectAll('#ribbon').attr("fill-opacity", 0.75)
        d3.selectAll("#colorline").selectAll('path').attr('fill-opacity',1)
        d3.select(this).data()[0].clicked = false
      }
      
  }
  function pathMouseOut(){
      d3.select(this)
        .attr('stroke-width', 3)
  }

  function render (){
      
      oldPathValue =  d3.selectAll('#colorline').selectAll('path').data()
      let maxV = parseInt(max- ((firH.attr('cy')-firHy)*divided))
      let minV =  parseInt(((secHy-secH.attr('cy'))*divided)+min)
      //test demomatrix
      var demomatrix =   Array.from(index, () => new Array(names.length).fill(0));
      for (const {source, target, value} of data) demomatrix[index.get(source)][index.get(target)] += value;
      for(let i =0;i<demomatrix.length;i++){
        for(let j=0 ; j < demomatrix[i].length;j++){
            if(demomatrix[i][j] < minV || demomatrix[i][j] > maxV){
              demomatrix[i][j] = 0
            }
        }
      }
  let newchords = chord(demomatrix.slice())
  svg.select("path")
  .attr("fill", "none")
  .attr("d", d3.arc()({outerRadius, startAngle: 0, endAngle: 2 * Math.PI}))

 svg
 .selectAll("#ribbon").remove()   ;


  svg.select('g').selectAll("g")
  .data(newchords)
  .join("path")
  .attr('id','ribbon')
  .attr("d", ribbon)

  .attr("fill", d => color(names[d.target.index]))
  .style("mix-blend-mode", "multiply")
  .append("title")
  .text(d => `${ribbons[0]} ${names[d.source.index]} ${ribbons[1]}${names[d.target.index]} ${ribbons[2]} ${d.source.value} ${ribbons[3]}`);
 d3.selectAll('#colorline').selectAll('path').remove()
 d3.selectAll('#colorline').selectAll('title').remove()

  svg.select("#colorline")
  .selectAll("g")
  .data(newchords.groups)
  .join("g")
  .call(g => g.append("path")
      .attr("d", arc)
      .attr('cursor','pointer')
      .each(d=> {d.clicked = false})
      .on('click',pathMouseClicked)
      .on('mouseover',pathMouseOver)
      .on('mouseout',pathMouseOut)
      .transition()
      .duration(700)
      .attrTween("d",d=> arcTween(d))
      .attr('id','colorline')
      .attr("fill", d =>  color(names[d.index]))
      .attr("stroke", d => color(names[d.index]))
      .attr('stroke-width', 3)
      )
      .each(async n=>{
              d3.select(document.getElementById(names[n.index]))
              .each(d =>{ 
                (d.newangle = (n.startAngle + n.endAngle) / 2)
              })
              .transition()
              .duration(700)
              .tween("text", function(d) {
                var i = d3.interpolate(d.angle, d.newangle);
                var rotate =d3.interpolate(0, 180);
                d.angle = d.newangle
                d3.select(document.getElementById(names[n.index]))
                .attr("text-anchor", d => d.angle > Math.PI ? "end" : null)
                return function(t) {
                  d3.select(this).attr("transform", d => `
                  rotate(${(i(t) * 180 / Math.PI - 90)})
                  translate(${outerRadius + 5})
                  ${d.newangle > Math.PI    ? `rotate(180)` : ""}  `)
                    };
                  }
                )
      })
      .call(g => g.append("title")
      .attr('id','colorline')
      .text(d => ` ${paths[0]}${names[d.index]} ${paths[1]} ${d3.sum(demomatrix[d.index])} ${paths[2]} ${d3.sum(demomatrix, row => row[d.index])}  ${paths[3]}`));
    }
    }
        chords(dataset,1600,900,['','=>','=','B'],['','=>','=>','B'],undefined)
    </script>
    </body>
        